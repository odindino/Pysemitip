""""
import math
import numpy as np
from semirhomult import effind, arho, rhob, rhocb, rhovb, rhoa, rhod, fjint, fd
from surfrhomult import enfind, rhos
from gsect import gsect
from semitip import*

# Constants
EPSIL0 = 8.854185e-12
E = 1.60210e-19
PI = 4.0 * math.atan(1.0)
SMALL_VALUE = 1e-10  # Threshold to prevent division by zero

# Parameters
NRDIM = int(512)
NVDIM = int(64)
NSDIM = int(512)
NPDIM = int(64)
NVDIM1 = NVDIM + 1
NVDIM2 = int(2048)
NSDIM2 = int(20000)
NEDIM = int(50000)
NREGDIM = int(2)
NARDIM = int(2)

# Arrays and Variables
VAC = [[[[0.0 for _ in range(NPDIM)] for _ in range(NVDIM)] for _ in range(NRDIM)] for _ in range(2)]
SEM = [[[[0.0 for _ in range(NPDIM)] for _ in range(NSDIM)] for _ in range(NRDIM)] for _ in range(2)]
VSINT = [[[0.0 for _ in range(NPDIM)] for _ in range(NRDIM)] for _ in range(2)]
R = [0.0 for _ in range(NRDIM)]
S = [0.0 for _ in range(NSDIM)]
DELV = [0.0 for _ in range(NRDIM)]
ITMAX = [10 for _ in range(10)]
EP = [0.0 for _ in range(10)]
BBIAS = [1000 for _ in range(1000)]
NLOC = [0 for _ in range(4)]
BARR = [0.0 for _ in range(NVDIM1)]
PROF = [0.0 for _ in range(NSDIM)]
AVBL = [0.0 for _ in range(NREGDIM)]
AVBH = [0.0 for _ in range(NREGDIM)]
AVBSO = [0.0 for _ in range(NREGDIM)]
ESO = [0.0 for _ in range(NREGDIM)]
TIP = [[[False for _ in range(NPDIM)] for _ in range(NVDIM)] for _ in range(NRDIM)]

# COMMON blocks equivalent
class SEMI:
    def __init__(self):
        self.TK = 0.0
        self.EGAP = [0.0 for _ in range(NREGDIM)]
        self.ED = [0.0 for _ in range(NREGDIM)]
        self.EA = [0.0 for _ in range(NREGDIM)]
        self.ACB = [0.0 for _ in range(NREGDIM)]
        self.AVB = [0.0 for _ in range(NREGDIM)]
        self.CD = [0.0 for _ in range(NREGDIM)]
        self.CA = [0.0 for _ in range(NREGDIM)]
        self.IDEG = [0 for _ in range(NREGDIM)]
        self.IINV = [0 for _ in range(NREGDIM)]
        self.DELVB = [0.0 for _ in range(NREGDIM)]
        self.EF = 0.0

SEMI = SEMI()

class PROTRU:
    def __init__(self):
        self.RAD2 = 0.0

PROTRU = PROTRU()

class SURF:
    def __init__(self):
        self.ISTK = 0
        self.TK1 = 0.0
        self.EN0 = [0.0 for _ in range(NARDIM)]
        self.EN = [[0.0 for _ in range(2)] for _ in range(NARDIM)]
        self.DENS = [[0.0 for _ in range(2)] for _ in range(NARDIM)]
        self.FWHM = [[0.0 for _ in range(2)] for _ in range(NARDIM)]
        self.ECENT = [[0.0 for _ in range(2)] for _ in range(NARDIM)]
        self.CHARGE_NEUTRALITY_LEVEL = 0.0

SURF = SURF()

class CD:
    def __init__(self):
        self.EF = 0.0
        self.ESTART = 0.0
        self.DELE = 0.0
        self.NE = 0
        self.RHOBTAB = [[0.0 for _ in range(NEDIM)] for _ in range(NREGDIM)]
        self.RHOSTAB = [[0.0 for _ in range(NEDIM)] for _ in range(NARDIM)]

CD = CD()

class TIPPOS:
    def __init__(self):
        self.X0 = 0.0
        self.Y0 = 0.0

TIPPOS = TIPPOS()

def is_number(s):
    try:
        float(s)
        return True
    except ValueError:
        return False

def read_parameters(filename):
    with open(filename, "r", encoding="utf-8") as file:
        lines = file.readlines()
        # Filter out comment lines and empty lines
        lines = [line.split('*')[0].strip() for line in lines if not line.strip().startswith('*') and line.strip()]
        lines = [','.join(line.split()) for line in lines]  # Replace spaces with single comma
        params = []
        idx = 0
        while idx < len(lines):
            if not lines[idx]:  # Skip empty lines
                idx += 1
                continue
            if idx == 0:
                try:
                    NPARM = int(lines[idx].split(',')[0])
                except ValueError:
                    print(f"Error parsing NPARM at line {idx}: {lines[idx]}")
                    break
                idx += 1
            else:
                try:
                    param_set = {
                        "SLOPE": float(lines[idx].split(',')[0]),
                        "SEPIN": float(lines[idx+1].split(',')[0]),
                        "RAD": float(lines[idx+2].split(',')[0]),
                        "RAD2": float(lines[idx+3].split(',')[0]),
                        "CPOT": float(lines[idx+4].split(',')[0]),
                        "X0": float(lines[idx+5].split(',')[0]),
                        "Y0": float(lines[idx+6].split(',')[0]),
                        "NREG": int(lines[idx+7].split(',')[0]),
                        "DOPING": []
                    }
                    idx += 8
                    for _ in range(param_set["NREG"]):
                        doping_set = {
                            "CD": float(lines[idx].split(',')[0]),
                            "CA": float(lines[idx+1].split(',')[0]),
                            "EGAP": float(lines[idx+2].split(',')[0]),
                            "DELVB": float(lines[idx+3].split(',')[0]),
                            "ED": float(lines[idx+4].split(',')[0]),
                            "EA": float(lines[idx+5].split(',')[0]),
                            "ACB": max(float(lines[idx+6].split(',')[0]), SMALL_VALUE),  # Prevent zero values
                            "AVBH": float(lines[idx+7].split(',')[0]),
                            "AVBL": float(lines[idx+8].split(',')[0]),
                            "AVB": math.exp(2.0 * math.log(max(math.sqrt(float(lines[idx+7].split(',')[0])**3) + math.sqrt(float(lines[idx+8].split(',')[0])**3), SMALL_VALUE)) / 3.0),
                            "AVBSO": float(lines[idx+9].split(',')[0]),
                            "ESO": float(lines[idx+10].split(',')[0]),
                            "IDEG": int(lines[idx+11].split(',')[0]),
                            "IINV": int(lines[idx+12].split(',')[0])
                        }
                        param_set["DOPING"].append(doping_set)
                        idx += 13
                    param_set.update({
                        "EPSIL": float(lines[idx].split(',')[0]),
                        "TEM": float(lines[idx+1].split(',')[0]),
                        "NAR": int(lines[idx+2].split(',')[0]),
                        "SURFACE_STATES": []
                    })
                    idx += 3
                    for _ in range(param_set["NAR"]):
                        surface_state_set = {
                            "DENS1": float(lines[idx].split(',')[0]),
                            "EN1": float(lines[idx+1].split(',')[0]),
                            "FWHM1": float(lines[idx+2].split(',')[0]),
                            "ECENT1": float(lines[idx+3].split(',')[0]),
                            "DENS2": float(lines[idx+4].split(',')[0]),
                            "EN2": float(lines[idx+5].split(',')[0]),
                            "FWHM2": float(lines[idx+6].split(',')[0]),
                            "ECENT2": float(lines[idx+7].split(',')[0])
                        }
                        param_set["SURFACE_STATES"].append(surface_state_set)
                        idx += 8
                    param_set.update({
                        "ISTK": int(float(lines[idx].split(',')[0])),  # Handle ISTK properly
                        "MIRROR": int(float(lines[idx+1].split(',')[0])),  # Handle MIRROR properly
                        "NR": int(float(lines[idx+2].split(',')[0])),  # Handle NR properly
                        "NV": int(float(lines[idx+3].split(',')[0])),  # Handle NV properly
                        "NS": int(float(lines[idx+4].split(',')[0])),  # Handle NS properly
                        "NP": int(float(lines[idx+5].split(',')[0])),  # Handle NP properly
                        "SIZE": float(lines[idx+6].split(',')[0]),
                        "IPMAX": int(float(lines[idx+7].split(',')[0])),  # Handle IPMAX properly
                        "ITMAX": [int(x) for x in lines[idx+8].split(',') if is_number(x.strip())],
                        "EP": [float(x) for x in lines[idx+9].split(',') if is_number(x.strip())],
                        "NE": int(float(lines[idx+10].split(',')[0])),  # Handle NE properly
                        "IWRITE": int(float(lines[idx+11].split(',')[0])),  # Handle IWRITE properly
                        "NBIAS": int(float(lines[idx+12].split(',')[0])),  # Handle NBIAS properly
                        "BBIAS": [float(x) for x in lines[idx+13].split(',') if is_number(x.strip())],
                        "NUMC": int(float(lines[idx+14].split(',')[0])),  # Handle NUMC properly
                        "DELPOT": float(lines[idx+15].split(',')[0]),
                        "PHIIN": float(lines[idx+16].split(',')[0]),
                        "CHI": float(lines[idx+17].split(',')[0]),
                        "EFTIP": float(lines[idx+18].split(',')[0]),
                        "NWK": int(float(lines[idx+19].split(',')[0])),  # Handle NWK properly
                        "NEE": int(float(lines[idx+20].split(',')[0])),  # Handle NEE properly
                        "EXPANI": int(float(lines[idx+21].split(',')[0])),  # Handle EXPANI properly
                        "FRACZ": float(lines[idx+22].split(',')[0]),
                        "BMOD": float(lines[idx+23].split(',')[0]),
                        "ANEG": float(lines[idx+24].split(',')[0]),
                        "APOS": float(lines[idx+25].split(',')[0]),
                        "VSTART": float(lines[idx+26].split(',')[0])
                    })
                    
                    params.append(param_set)
                    idx += 27
                except Exception as e:
                    print(f"Error parsing parameters at line {idx}: {lines[idx]}")
                    print(e)
                    break
    return params

def main(params):
    semi = SEMI
    surf = SURF

    for param in params:
        SLOPE = param["SLOPE"]
        SEPIN = param["SEPIN"]
        RAD = param["RAD"]
        RAD2 = param["RAD2"]
        CPOT = param["CPOT"]
        X0 = param["X0"]
        Y0 = param["Y0"]
        NREG = param["NREG"]

        # Print semiconductor and tip parameters
        print(f"RAD, SLOPE, ANGLE = {RAD:.8f} {SLOPE:.8f} {360.0 * math.atan(1.0 / SLOPE) / PI:.6f}")
        print(f"CONTACT POTENTIAL = {CPOT:.7f}")
        print(f"POSITION OF TIP = {X0:.7f} {Y0:.7f}")
        print(f"NUMBER OF DIFFERENT REGIONS OF SEMICONDUCTOR = {NREG}")

        if NREG > NREGDIM:
            raise ValueError("INPUT NUMBER OF REGIONS > NUMBER OF REGIONS IN PARAMETER STATEMENT")

        for i, doping in enumerate(param["DOPING"]):
            print(f"REGION # {i + 1}")
            print(f"DOPING = {doping['CD']:.8E} {doping['CA']:.7f}")
            print(f"BAND GAP, VB OFFSET = {doping['EGAP']:.7f} {doping['DELVB']:.7f}")

        EPSIL = param["EPSIL"]
        TEM = param["TEM"]
        semi.TK = TEM * 8.617e-5
        surf.CHARGE_NEUTRALITY_LEVEL = param["SURFACE_STATES"][0]["EN1"]  # 直接設定這裡的值
        semi.EF = surf.CHARGE_NEUTRALITY_LEVEL
        NAR = param["NAR"]

        print(f"NUMBER OF DIFFERENT AREAS OF SURFACE STATES = {NAR}")
        if NAR > NARDIM:
            raise ValueError("INPUT NUMBER OF AREAS > NUMBER OF AREAS IN PARAMETER STATEMENT")

        for i, surface_state in enumerate(param["SURFACE_STATES"]):
            print("FIRST DISTRIBUTION OF SURFACE STATES:")
            print(f"SURFACE STATE DENSITY, EN = {surface_state['DENS1']:.8E} {surface_state['EN1']:.8f}")
            print(f"FWHM, ECENT = {surface_state['FWHM1']:.8f} {surface_state['ECENT1']:.7f}")
            print("SECOND DISTRIBUTION OF SURFACE STATES:")
            print(f"SURFACE STATE DENSITY, EN = {surface_state['DENS2']:.7f} {surface_state['EN2']:.7f}")
            print(f"FWHM, ECENT = {surface_state['FWHM2']:.7f} {surface_state['ECENT2']:.7f}")

        ISTK = param["ISTK"]
        MIRROR = param["MIRROR"]
        NR = param["NR"]
        NV = param["NV"]
        NS = param["NS"]
        NP = param["NP"]
        SIZE = param["SIZE"]
        IPMAX = param["IPMAX"]
        ITMAX = param["ITMAX"]
        EP = param["EP"]
        NE = param["NE"]
        IWRITE = param["IWRITE"]
        NBIAS = param["NBIAS"]
        BBIAS = param["BBIAS"]
        NUMC = param["NUMC"]
        DELPOT = param["DELPOT"]
        PHIIN = param["PHIIN"]
        CHI = param["CHI"]
        EFTIP = param["EFTIP"]
        NWK = param["NWK"]
        NEE = param["NEE"]
        EXPANI = param["EXPANI"]
        FRACZ = param["FRACZ"]
        BMOD = param["BMOD"]
        ANEG = param["ANEG"]
        APOS = param["APOS"]
        VSTART = param["VSTART"]
        DELRIN = param.get("DELRIN", 1.0)  # 设置默认值
        DELSIN = param.get("DELSIN", 1.0)
        DELXSI = np.zeros(NRDIM)
        IINIT = 1
        if MIRROR == 1:
            print("HORIZONTAL MIRROR PLANE ASSUMED")
            if Y0 != 0.0:
                print("*** WARNING - Y0 <> 0 WITH MIRROR PLANE; WILL SET Y0 TO ZERO")
                Y0 = 0.0
        for ireg in range(NREG):
            EF = effind(ireg, semi, arho, gsect, rhob, rhocb, rhoa, rhovb, rhod, fjint)
            if np.isinf(EF) or np.isnan(EF):
                EF = 0.0  # Handle invalid EF values
            param["EF"] = EF  # 将计算得到的EF值添加到参数字典中
            print(f"REGION TYPE {ireg + 1}, FERMI-LEVEL = {EF}")
            RHOCC = rhocb(ireg, EF, 0, semi, fjint)
            RHOVV = rhovb(ireg, EF, 0, semi, fjint)
            print(f"CARRIER DENSITY IN CB, VB = {RHOCC}, {RHOVV}")
        RHOCC = doping["CD"] * math.exp((semi.EF - semi.TK) / (8.617e-5 * TEM))  # Example calculation
        RHOVV = doping["CA"] * math.exp((semi.TK - semi.EF) / (8.617e-5 * TEM))
        SEP0 = SEPIN - abs(VSTART) * ANEG if VSTART < 0 else SEPIN - abs(VSTART) * APOS
        print(f"REGION TYPE 1, FERMI-LEVEL = {semi.EF:.7f}")
        print(f"CARRIER DENSITY IN CB, VB = {RHOCC:.8E} {RHOVV:.7f}")  # Replace with actual calculations

        # Iterate over a limited set of bias points to avoid excessive output
        for BIAS0 in BBIAS[:1]:  # Limiting to 3 points for demonstration
            SEP = SEP0 + ANEG * abs(BIAS0) if BIAS0 <= 0 else SEP0 + APOS * abs(BIAS0)
            print(f"SEPARATION = {SEP:.8f}")
            BIAS = BIAS0 + (-1 if BMOD == 0 else 1) * BMOD * math.sqrt(2.0)
            POTTIP = BIAS + CPOT
            print(f"BIAS, TIP POTENTIAL = {BIAS:.8f} {POTTIP:.8f}")
            W = 1.0e9 * math.sqrt(2.0 * EPSIL * EPSIL0 * max(1.0, abs(POTTIP)) / (abs(doping["CD"] - doping["CA"]) * 1.0e6 * E)) if (doping["CD"] - doping["CA"]) != 0 else 1.0e10
            print(f"1-D ESTIMATE OF DEPLETION WIDTH (NM) = {W:.8f}")

            ESTART = min(semi.TK, semi.TK - POTTIP, min([surface_state["EN1"] for surface_state in param["SURFACE_STATES"]]))
            EEND = max(semi.TK, semi.TK - POTTIP, max([surface_state["EN1"] for surface_state in param["SURFACE_STATES"]]))
            ETMP = EEND - ESTART
            ESTART = ESTART - 2.0 * ETMP
            EEND = EEND + 2.0 * ETMP
            DELE = (EEND - ESTART) / float(NE - 1)
            NETMP = int((semi.TK - ESTART) / DELE)
            ESTART = semi.TK - (NETMP - 0.5) * DELE
            EEND = ESTART + (NE - 1) * DELE
            print(f"ESTART,EEND,NE = {ESTART:.7f} {EEND:.7f} {NE}")

            # Placeholder for calls to SEMIRHO and SURFRHO
            print("COMPUTING TABLE OF BULK CHARGE DENSITIES")
            print("COMPUTING TABLE OF SURFACE CHARGE DENSITIES")

        # Call SEMITIP3
        POT0 = 0.0  # Initialize POT0
        IERR = 0  # Initialize IERR
        ETAT, A, Z0, C, DELR, DELS, DELV, DELP, NR, NS, NV, NP, POT0, IERR = semitip3(SEP, RAD, SLOPE, DELRIN, DELSIN, VAC, TIP, SEM, VSINT, R, S, DELV, DELR, DELXSI, DELP, 
             NRDIM, NVDIM, NSDIM, NPDIM, NR, NV, NS, NP, BIAS, IWRITE, ITMAX, EP, IPMAX, POT0, IERR, 
             IINIT, MIRROR, EPSIL, DELS)
   
        
        # Print results
        print(f"RETURN FROM SEMITIP3, NR, NS, NV, IERR = {NR}, {NS}, {NV}, {IERR}")

if __name__ == "__main__":
    params = read_parameters("fort_new.9")
    main(params)
if iter_count >=10:  # 強制在50次迭代後停止
            return pot0, 1, iter_count  # 將第二個返回值設置為1表示停止
            break
"""